# Cycle Sort Algorithm

Cycle Sort is an in-place and unstable sorting algorithm that is often used when minimizing the number of writes to a data storage device is a primary concern. Unlike many sorting algorithms, Cycle Sort does not compare elements to determine their order; instead, it positions elements by cycling through the array.

## How Cycle Sort Works

1. **Cycle Detection**:
   - Start with the first element and consider it as an "item to be placed."
   - Find the correct position for the item by counting the number of items less than it.
   - Swap the item with the element at its correct position.
   - Continue this process until you encounter the initial element. This completes one cycle.

2. **Repeat Cycles**:
   - Repeat the cycle detection process for all remaining unsorted elements.
   - This step may involve multiple cycles.

3. **Completion**:
   - Once all elements are sorted, the algorithm terminates.

## Key Features

- **In-Place Sorting**: Cycle Sort sorts the elements in the original array without using additional memory for temporary storage.
- **Unstable Sort**: It does not guarantee the relative order of equal elements.
- **Optimized for Minimizing Writes**: Cycle Sort is often used when minimizing the number of writes to a storage device is essential. This property is particularly useful in flash memory and other write-sensitive environments.

## Efficiency

- **Time Complexity**: Cycle Sort has a time complexity of O(n^2) in the worst and average cases, making it less efficient than many other sorting algorithms, especially for large datasets.
- **Space Complexity**: It has a space complexity of O(1) as it sorts elements in place.

## Limitations

- Cycle Sort's primary advantage is minimizing the number of writes, but its quadratic time complexity makes it less suitable for sorting large datasets.
- It is an unstable sort, meaning it may change the relative order of equal elements.

Overall, Cycle Sort is a sorting algorithm primarily used in scenarios where minimizing write operations is critical, even at the expense of additional time complexity.

## Code
```js filename="Sorting-Algo/cs.js"
function cycleSort(arr) {
    const n = arr.length;
    for (let cycleStart = 0; cycleStart < n - 1; cycleStart++) {
        let item = arr[cycleStart];
        let pos = cycleStart;

        // Find the position for the current item
        for (let i = cycleStart + 1; i < n; i++) {
            if (arr[i] < item) {
                pos++;
            }
        }

        // If the item is already at the correct position, skip it
        if (pos === cycleStart) {
            continue;
        }

        // Move the item to its correct position
        while (item === arr[pos]) {
            pos++;
        }
        const temp = arr[pos];
        arr[pos] = item;
        item = temp;

        // Perform cycle rotation
        while (pos !== cycleStart) {
            pos = cycleStart;
            for (let i = cycleStart + 1; i < n; i++) {
                if (arr[i] < item) {
                    pos++;
                }
            }

            while (item === arr[pos]) {
                pos++;
            }
            const temp = arr[pos];
            arr[pos] = item;
            item = temp;
        }
    }
}

// Example usage:
const arr = [64, 34, 25, 12, 22, 11, 90];
cycleSort(arr);
console.log("Sorted array: " + arr);


```