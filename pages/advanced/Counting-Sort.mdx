# Counting Sort

**Counting Sort is a non-comparison-based sorting algorithm that works well when there is limited range of input values. It is particularly efficient when the range of input values is small compared to the number of elements to be sorted. The basic idea behind Counting Sort is to count the frequency of each distinct element in the input array and use that information to place the elements in their correct sorted positions. **
 

## Code
```js filename="Sorting-Algo/mg.js"
function mergeSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  // Split the array into two halves
  const middle = Math.floor(arr.length / 2);
  const leftHalf = arr.slice(0, middle);
  const rightHalf = arr.slice(middle);

  // Recursively sort each half
  const sortedLeft = mergeSort(leftHalf);
  const sortedRight = mergeSort(rightHalf);

  // Merge the sorted halves
  return merge(sortedLeft, sortedRight);
}
function mergeSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  // Split the array into two halves
  const middle = Math.floor(arr.length / 2);
  const leftHalf = arr.slice(0, middle);
  const rightHalf = arr.slice(middle);

  // Recursively sort each half
  const sortedLeft = mergeSort(leftHalf);
  const sortedRight = mergeSort(rightHalf);

  // Merge the sorted halves
  return merge(sortedLeft, sortedRight);
}
function countingSort(arr) {
  // Find the maximum and minimum values in the array
  let max = arr[0];
  let min = arr[0];
  const n = arr.length;

  for (let i = 1; i < n; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
    if (arr[i] < min) {
      min = arr[i];
    }
  }

  // Create a counting array to store the count of each element
  const countArray = new Array(max - min + 1).fill(0);

  // Count the occurrences of each element
  for (let i = 0; i < n; i++) {
    countArray[arr[i] - min]++;
  }

  // Reconstruct the sorted array from the counting array
  let sortedIndex = 0;
  for (let i = 0; i < countArray.length; i++) {
    while (countArray[i] > 0) {
      arr[sortedIndex] = i + min;
      sortedIndex++;
      countArray[i]--;
    }
  }
}

// Example usage:
const unsortedArray = [4, 2, 2, 8, 3, 3, 1];
countingSort(unsortedArray);
console.log(unsortedArray); 

```

## Output
```
[1, 2, 2, 3, 3, 4, 8]
```

## Tracing 
Here are step-by-step instructions for tracing selection sort:

**Initial State: Write down the unsorted array.**
Unsorted: **[4, 2, 2, 8, 3, 3, 1]**

**Step 1 (Splitting the Array):**
Divide the array into two equal halves: [38, 27, 43] and [3, 9, 82, 10].

**Find Maximum and Minimum Values:**
Find the maximum and minimum values in the array.
Maximum: 8
Minimum: 1

**Create the Counting Array:**
Create a counting array with a size equal to the range of values (max - min + 1).
In this case, the range is 8 - 1 + 1 = 8, so the counting array has 8 elements, initialized with zeros.
Counting Array: **[0, 0, 0, 0, 0, 0, 0, 0]**

**Count the Occurrences:**
Count the occurrences of each element in the original array and update the counting array accordingly.
Counting Array After Counting: **[1, 2, 2, 2, 1, 0, 0, 1]**

**Reconstruct the Sorted Array:**
Iterate through the counting array and reconstruct the sorted array.
For each element in the counting array:
Place the element back in the original array, taking into account the minimum value.
Update the counting array to reflect the used count.
The sorted array is built step by step:
**[1]
[1, 2, 2]
[1, 2, 2, 3, 3]
[1, 2, 2, 3, 3, 4]
[1, 2, 2, 3, 3, 4, 8]**

**Final State: All elements are now sorted.
Sorted Array: [1, 2, 2, 3, 3, 4, 8]**

These steps show how Counting Sort works by first counting the occurrences of each element and then reconstructing the sorted array based on the counts and the range of values.